#include <Keypad.h>

//Access code
const String CODE = "1234";
//Emergency key
const String EMERGENCYKEY = "***";

//Initialize timer global variables
unsigned long startTime;
unsigned long currTime;
//Initialize room-state global variable as if you're outside the room
boolean entered = false;

//Initialize pin global variables
int buzzerPin = 5;  // the number of the buzzer pin
int echoPin = 6;    // Echo Pin of Ultrasonic Sensor
int pingPin = 7;    // Trigger Pin of Ultrasonic Sensor
int greenLed = 11;
int redLed = 12; // 

// Keypad setup
byte R1 = A0;      // top most row on numbpad
byte R2 = A1;      // top mid row on numbpad
byte R3 = A2;    // bottom middle row
byte R4 = A3;     //bottom most row
byte C1 = 8;      // left most column on numpad
byte C2 = 9;       //center left column on numpad
byte C3 = 10;    // right column on numbpad

const byte ROWS = 4;
const byte COLS = 3;
char hexaKeys[ROWS][COLS] = {
  {'1', '2', '3'},
  {'4', '5', '6'},
  {'7', '8', '9'},
  {'*', '0', '#'}
};

byte rowPins[ROWS] = {R1, R2, R3, R4};
byte colPins[COLS] = {C1, C2, C3};

Keypad customKeypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);         // Starting Serial Terminal
  pinMode(echoPin, INPUT);    // To receive the wave
  pinMode(pingPin, OUTPUT);   // To send the wave
  pinMode(buzzerPin, OUTPUT); // Set Buzzer pin to output mode
  pinMode(greenLed, OUTPUT);
  pinMode(redLed, OUTPUT);
}

void loop() {
  // This all checks the distance in cm:
  float duration, cmDist;
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(pingPin, LOW);
  duration = pulseIn(echoPin, HIGH);
  cmDist = microsecondsToCentimeters(duration);
  Serial.print(cmDist);
  Serial.println("cm");

  if (fabs(cmDist - 15) > 5) {
    if (!entered) {
      Serial.println("You're trying to get in");
      authorize();
    } else {
      Serial.println("You're leaving the room");
      entered = false;
      delay(5000);
    }
  } else {
    noTone(buzzerPin);
  }
}

//sketch timer execution
void authorize() {
  startTime = millis();
  boolean check = checkPin();
  if (check) {
    correct();
  } else {
    incorrect();
  }
}

void correct() {
  Serial.println("Welcome");
  noTone(buzzerPin);
  entered = true;
  digitalWrite(greenLed, HIGH);
  delay(3000);
  digitalWrite(greenLed, LOW);
}

void incorrect() {
  Serial.println("Try again");
  ringAlarm();
  // turn on red LED
}

// checks the 4 digit pin, returns true if code is correct or the emergecy key
// # is reset button
//
boolean checkPin() {
  String input = "";
  currTime = millis();
  while (input.length() < 4 && (currTime - startTime) < 30000) {
    char digit = customKeypad.getKey();
    
    if (input.equals(EMERGENCYKEY)) {
      return true;
    } else if (digit == '#') {
      input = "";
      Serial.println("Cleared input");
    } else if (digit != NO_KEY) {
      Serial.println(digit);
      input = input + digit;
    }
    
    currTime = millis();
    if (currTime - startTime > 30000) {
      Serial.println("Time out");
      ringAlarm();
    }
    
  }
  Serial.println("You've fully entered a code or time is up");
  return input.equals(CODE);
}

void ringAlarm() {
  float sinVal;       // Define a variable to save sine value
  int toneVal;        // Define a variable to save sound frequency
  int x = 0;
  char key = customKeypad.getKey();
  while (key == NO_KEY || key != '*') {
    sinVal = sin(x * (PI / 180));   // Calculate the sine of x
    toneVal = 2000 + sinVal * 500;  // Calculate sound frequency according to the sine of x
    tone(buzzerPin, toneVal);       // Output sound frequency to buzzerPin
    delay(1);
    
    if(x % 360 == 0) {
      digitalWrite(redLed, HIGH);
    } else if (x % 360 == 180) {
      digitalWrite(redLed, LOW);
    }
    
    x++;

    key = customKeypad.getKey();
    if (key == '*') {
      noTone(buzzerPin);
      digitalWrite(redLed, LOW);
      startTime = millis(); // restart time
      //key = NO_KEY;
      authorize();
      //break;
    }
  }
}

float microsecondsToCentimeters(long microseconds) {
  return microseconds / 29.0 / 2.0;
}
